Files:
    reference-llvm/src

--------------

Meta:
    Title: Channels Extension
    Date: 10/2/15
    Project: compiler
    Groups: extensions

--------------

Body:

1.) What will the channel extension provide?

    The primary goal is task-to-task communication using unidirectional FIFOs.
    These will be provided as direct syntax elements, not intrinsics, and
    managed by the compiler, not the runtime.

2.) Why not the runtime?

    Having compiler-managed channels allows the extension to be transparently
    enabled and disabled without runtime changes, and theoretically will lead
    to betted integration with the language and better performance.

    Additionally, more channel errors will be able to be caught at compile-time.

3.) How do channels work?

    Channels are modeled after Unix sockets. Because of this, there are two
    types of channels: listen channels and communication channels.

    Listen channels are created by a task that wishes to allow another task
    to communicate with it. They are registered with a numeric index which
    must be unique among all listen channels, even those in other tasks.
    This is because listen channels are not tied to a particular task,
    like sockets are to an address. A task does not have to know anything about
    the task it is connecting to for communication to take place.

    Once a listen channel has been established by a task, that task can wait
    for communication to be opened in a blocking or non-blocking manner.
    The task then receives the index of a communication channel which it can
    use to receive messages.

    Connections may (undecided as yet) automatically include a reverse channel
    that the listening task can use to send messages.

    this isn't true {
    It is theoretically possible for a task to spoof a communication channel
    index without having opened it via a listen channel. This is likely to not
    work very well, and it's behavior is officially undefined.
    It's possible that it could be used intentionally, although care would
    have to be taken.
    }

    Channels can buffer a fixed number of messages before they are "full."
    Operations will likely provided to query the status of a channel, e.g.
    the space remaining or whether messages are available to be read.
    Like listen channels, communcation channels can be accessed in a blocking
    or non-blocking manner on both ends.

4.) What benefit do channels provide over globals?

    A few: one, they encourage a "right is easy" way of task-to-task
    communication; two, they can more easily be adapted to a runtime that
    requires critical sections, as it is clear that all channel accesses
    are by their nature shared -- in fact, fine-grained critical sections
    could be placed around channels, as the only shared data is the insert
    location and message count; three, they have clearly defined access
    semantics, there is no concept of local caching -- a channel is either
    read-only or write-only, this at least simplifies, if not solves, the
    recently discovered issue with globals.

5.) What are the proposed syntax elements for channels?

    An example:

        function server() {
            open l; // creates listen channel "l"
            accept c0 from l on 17; // creates communication channel "c0" (blocking)
            close l; // stop listening
            msg = *c0; // receives mesage (blocking)
            if (msg == 0) {
                // do something
            } else {
                // do something else
            }
            close c0; // stop receiving
        }

        function client() {
            open c0;
            connect c0 to 17;
            *c0 = 7;
        }

6.) Why this syntax? (Especially the business with *?)

    This syntax was designed so that channels can be kept in an entirely
    seperate namespace from variables -- preserving the type system.
    All actions refer unambiguously to channels or variables.

    The "accept" syntax was chosen for listen sockets over * syntax because
    it creates a new channel, not a new variable. This means that *c always
    returns a numeric, never a channel. Additionally, the accept syntax
    was chosen so that it does not involve an "=", further seperating it
    from variables.
    The * syntax allows reading to be included in expressions, while the
    version for writing is easily identified by the grammar as different
    from an assignment statement -- another benfit of "=" not being an operator.

7.) Okay, what about blocking vs nonblocking and checking the number of
    messages?

    Reading and writing with *, and creation with "accept" are blocking
    operations. The only way to avoid blocking is with some sort of "ready"
    check. The proposed syntax must be part of the expression language, as a
    key use will be in an if or while statement.
    The working idea is to introduce a unary $ operator that only works on
    channels, and returns the number of acceptable connections for a listener,
    the number of available spaces for a sender, and the number of waiting
    messages for a receiver.

    An example:

        while { $c0 > 0; } do {
            m = *c0; // read message
        }

8.) Is there a limit on the number of channels?

    The only hard limit is on the number of actively listening channels.
    This is fixed at compile time and is simply an array of pointers
    to channels.

    The channels themselves are allocated on their owning task's stack:
    the server for listening channels and the client for communication
    channels. Communication channels pass a pointer when connecting and
    listening channels register one in the aforementioned array.

    This means, however, that channels "go away" when the function that
    created them returns! Something to alleviate this problem may be
    developed in the future...

    Channels should be closed if there is any chance of them being
    accessed after their owning function returns, and probably even if there
    isn't.

    This does mean that the true limit is from the stack size allocated to
    a given task. The size of a channel is four times queue size plus 16
    bytes, so for a queue size of 8, 11 channels would overflow a "small"
    task (less if it has called functions.)

9.) What about performance?

    Channel performance should be very good, with messages being sent and
    received in constant time. Registering a listening socket takes constant
    time as well (well, it's O(n) with the size of the listener array, which
    is fixed at compile time) because it has to loop over the whole array to
    make sure no one else is listening on the requested port.

    Connecting is similar, although it can bail out early as soon as it finds
    a matching port, so in practice it will be slightly faster.

    Transmit and receive are performed in-line without a function call,
    further increasing their performance at the expense of a potentially
    larger code footprint.
    By default, they operate in "safe" mode, checking that their operation
    will succeed before performing it, but this can be disabled at compile
    time. This also has the effect of disabling repeat-port verification.

    Accept and connect operations are not inlined and instead call small, fast
    leaf functions. Open is simply an alloca.

--------------
